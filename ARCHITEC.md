# Архитектура и логика проекта

Этот документ описывает структуру и работу Telegram-бота, чтобы быстро погрузиться в проект и
продолжить разработку.

## Краткое описание

Проект — Telegram-бот на Deno + TypeScript с библиотекой grammY. Бот ведет пользователя по цепочке
сообщений, организованной по дням. Состояние хранится в памяти процесса, ежедневная рассылка
управляется простым планировщиком. Доступ к premium дням контролируется подпиской ЮKassa.

## Структура проекта

- `src/index.ts` — точка входа: инициализация бота, роутинг команд/событий, запуск планировщика.
- `src/config.ts` — загрузка конфигурации из окружения и парсинг времени.
- `src/types/state.ts` — типы и in-memory хранилище состояния пользователей.
- `src/services/message-flow.ts` — основная логика цепочки сообщений, обработка feedback.
- `src/services/scheduler.ts` — ежедневная отправка следующего дня в режиме prod.
- `src/services/payments.ts` — создание платежей ЮKassa и обработка webhook.
- `src/services/reminders.ts` — логика напоминаний для шагов с feedback.
- `src/db/schema.ts` — ORM-модели (Drizzle).
- `migrations/001_init.sql` — начальная миграция схемы БД.
- `migrations/003_messages.sql` — таблицы сообщений/feedback.
- `seeds/001_messages.sql` — наполнение базовыми сообщениями.
- `storage/messages.json` — внешнее хранилище данных (сейчас не используется в коде).
- `dist/index.js` — собранный файл (если используется сборка/запуск вне Deno).
- `deno.json`, `deno.lock` — настройки и задачи Deno.
- `package.json`, `pnpm-lock.yaml`, `node_modules` — артефакты npm-зависимостей (используется grammY
  через npm:).

## Конфигурация и окружение

Файл `src/config.ts`:

- `BOT_TOKEN` — токен Telegram бота (обязательно).
- `BOT_MODE` — `dev` или `prod` (по умолчанию `dev`).
- `DAILY_SEND_TIME` — время ежедневной отправки в формате `HH:MM` (по умолчанию `10:00`).

В режиме `dev` ежедневная рассылка не запускается.

Для работы с БД планируется использовать ORM Drizzle. Подключение выполняется через `DATABASE_URL`.

## Модель данных

### Состояние пользователя

Файл `src/state.ts`:

- `UserState`:
  - `day` — номер текущего дня.
  - `messageIndex` — индекс текущего сообщения внутри дня.
  - `status` — `active`, `scheduled` или `blocked` (ожидание оплаты).
  - `reminder_due_at`, `reminder_sent_at` — поля для напоминаний.
- `StateStore` — `Map<number, UserState>`, ключ — `chatId`.

Хранилище in-memory, при перезапуске состояние теряется.

### Пользователи (личные чаты)

Бот работает только в личных сообщениях, поэтому модель упрощена: достаточно таблицы пользователей и
их состояния. `tg_user_id` фактически равен `tg_chat_id` для приватного чата.

Предлагаемая минимальная схема:

- `users`
  - `id` — внутренний UUID/serial.
  - `tg_user_id` — Telegram user id (уникальный).
  - `username` — Telegram username (nullable).
  - `first_name`, `last_name` — данные профиля (nullable).
  - `created_at`, `updated_at`.

- `user_state`
  - `user_id` — связь с `users`.
  - `day`, `message_index`, `status`.
  - `updated_at`.

### Контент по дням

Сообщения хранятся в БД:

- `bot_days` — описание дня (`day_number`, `is_premium`, `reminders`).
- `bot_messages` — сообщения дня (с порядком `step_index`).
- `bot_feedback_buttons` — кнопки для feedback.
- `bot_feedback_messages` — ответы на feedback по типу.

Для наполнения данных используется `seeds/001_messages.sql`.

## Основные компоненты и потоки

### 1) Точка входа и маршрутизация

Файл `src/index.ts`:

- Загружает конфиг и создает `Bot`.
- Инициализирует `state` и сервисы `message-flow` и `scheduler`.
- Регистрирует обработчики:
  - `/start` — стартует день 0.
  - `/test_day_<n>` — форс-старт конкретного дня.
  - `callback_query:data` — обработка feedback-кнопок с префиксом `fb:`.
  - `message` — любые сообщения, чтобы продолжить активную цепочку.
- Запускает планировщик и самого бота.

### 2) Логика цепочки сообщений

Файл `src/services/message-flow.ts` реализует правила продвижения по цепочке:

- `startDayNow(chatId, day)`:
  - Проверяет наличие дня в `BOT_MESSAGES_MAP`.
  - Если день помечен `isPremium`, проверяет подписку. Без доступа — отправляет оффер и переводит
    пользователя в `blocked`.
  - Записывает состояние пользователя (`status: active`) и запускает `sendChain`.

- `sendChain(chatId)`:
  - Пока пользователь `active`, отправляет сообщения последовательно.
  - Если у сообщения есть `feedback.buttons`, отправка цепочки останавливается и ждет клика.
  - При остановке на feedback ставит напоминание через 12 часов.
  - Пустые сообщения пропускаются, чтобы не получить ошибку Telegram.
  - После каждого сообщения вызывает `advanceState`.

- `processFeedback(chatId, type)`:
  - Находит ответ на кнопки в `feedback.messages` и отправляет его.
  - Продвигает состояние и продолжает цепочку.
  - Снимает напоминание.

- `handleMessage(chatId)`:
  - Используется для любого входящего текста.
  - Ничего не анализирует, просто продолжает цепочку, если пользователь активен.

- `advanceState(chatId)`:
  - Если есть еще сообщения в текущем дне — увеличивает `messageIndex`.
  - Если день закончился, переходит к следующему по порядку (сначала free, затем premium):
    - Если следующий день `isPremium` и нет подписки — отправляет оффер и переводит в `blocked`.
    - Иначе переводит в `scheduled` в режиме `prod`, либо `active` в `dev`.
  - Если следующего дня нет — удаляет состояние пользователя.

### 3) Планировщик ежедневной отправки

Файл `src/services/scheduler.ts`:

- Запускается только в режиме `prod`.
- Каждую минуту проверяет время.
- Если время совпало с `DAILY_SEND_TIME`, запускает `startDay` для пользователей со статусом
  `scheduled`.

## Логика событий Telegram

- `/start` — стартует первый доступный день (free → premium) и отправляет цепочку до feedback.
- `/test_day_<n>` — ручной старт любого дня для тестирования.
- Нажатие кнопки feedback:
  - Callback-данные вида `fb:<type>`.
  - По типу отправляется связанный ответ.
  - Цепочка продолжается до следующего feedback.
- Любое сообщение пользователя:
  - Используется как триггер, чтобы продолжить цепочку в активном состоянии.

## Расширение и точки для доработки

- Персистентное хранение состояния (заменить `Map` на БД или файл).
- Загрузка контента сообщений из JSON/БД вместо hardcoded `storage/meaasge.ts`.
- Механизм оплаты/доступа к `isPremium` дням.
- Переход на более точный планировщик (cron) и обработка часового пояса.
- Обработка пользовательских ответов (парсинг текста) вместо простого continue.

## Платежи (ЮKassa) и доступ к premium

Текущая архитектура:

- Таблица `payments`:
  - `id`, `user_id`/`chat_id`, `provider` (`yookassa`), `status`, `amount`, `currency`, `payment_id`
    (id провайдера), `idempotency_key`, `created_at`, `updated_at`.
- Таблица `subscriptions` (если нужна подписка):
  - `id`, `user_id`, `status`, `plan`, `start_at`, `end_at`, `payment_id`.

Поток:

1. Бот создает платеж в ЮKassa, пишет `payments` со статусом `pending`.
2. Пользователь оплачивает, ЮKassa отправляет webhook `payment.succeeded`.
3. Webhook обновляет `payments.status`, создает `subscriptions` и отправляет сообщение об успехе.
4. Если пользователь был в `blocked`, бот запускает премиум-день автоматически.

Return URL:

- `GET /return` — простая HTML-страница с кнопкой перехода в Telegram (используется в
  `YOOKASSA_RETURN_URL`).

## Напоминания

Механизм напоминаний для шагов с feedback:

- `bot_messages.reminder_text` — опциональный текст напоминания для конкретного шага.
- `user_state.reminder_due_at` / `reminder_sent_at` — планирование и отметка отправки.
- Фоновая проверка раз в минуту отправляет напоминания, если пользователь всё ещё на том же шаге.
- `REMINDER_DELAY_HOURS` — задержка перед отправкой напоминания (по умолчанию 12 часов).

## Очереди/брокер сообщений

Рекомендации для обработки платежей и фоновых задач:

- Минимальный вариант: таблица `jobs` в Postgres (polling воркером).
- Более надежный вариант: Redis + очередь (BullMQ/bee-queue или аналог).
- Тяжелые нагрузки: отдельный брокер (RabbitMQ/NATS).

Выбор зависит от объема платежей и требуемой гарантии доставки. Для старта обычно достаточно
Postgres + простой воркер.

## Webhooks

Для платежей и интеграций понадобится HTTP-сервер:

- Endpoint `/webhooks/yookassa` принимает события ЮKassa и обновляет `payments`.
- Логика webhooks идемпотентна: повторные события не создают новую подписку.
- Ошибки обработки должны логироваться и повторно обрабатываться через очередь.

Рекомендация: вынести webhook-обработчик в отдельный сервис/роутер и подключить при запуске вместе с
ботом.

## Быстрый сценарий работы

1. Пользователь пишет `/start`.
2. Бот отправляет сообщения дня 0 до кнопки.
3. Пользователь нажимает кнопку feedback.
4. Бот отвечает на feedback и продолжает цепочку.
5. После завершения дня пользователь переводится в `scheduled` (prod) и получает следующий день по
   расписанию.

## Важно знать

- Состояние в памяти, перезапуск процесса сбрасывает прогресс.
- Планировщик проверяет время раз в минуту, возможна задержка до 60 секунд.
- В `storage/meaasge.ts` есть опечатка в имени файла; это используется в импорте и менять имя нужно
  аккуратно.
